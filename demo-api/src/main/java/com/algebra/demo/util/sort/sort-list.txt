【sort】
参考：
    https://www.cnblogs.com/onepixel/articles/7674659.html
    https://blog.csdn.net/weixin_41190227/article/details/86600821
    https://www.runoob.com/w3cnote/sort-algorithm-summary.html

比较类排序：
-- 交换排序：
    -- 冒泡排序         BubbleSort
    -- 快速排序         QuickSort
-- 插入排序：
    -- 简单插入排序     InsertionSort
    -- 希尔排序         ShellSort
-- 选择排序：
    -- 简单选择排序     SelectionSort
    -- 堆排序           HeapSort
-- 归并排序：           MergeSort
    -- 二路归并排序
    -- 多路归并排序


非比较类排序：
-- 计数排序             CountSort
-- 桶排序               BucketSort
-- 基数排序             RadixSort


【动态规划经典问题-LeetCode】
1、LeetCode70 爬楼梯
2、LeetCode198 打家劫舍
3、LeetCode53 最大子序和
4、LeetCode322 找零钱
5、LeetCode120 三角形
6、LeetCode300 最长上升子序列
7、LeetCode64 最小路径和
8、LeetCode174 地下城游戏


https://www.jianshu.com/p/a46ee4ed2a8f

【bitmap】
[字节占用]
1.整型
类型              存储需求         bit数    取值范围           备注
int               4字节           4*8      -2^31 ~ 2^31-1
short             2字节           2*8      -32768 ~ 32767
long              8字节           8*8      -2^63 ~ 2^63-1    long类型有一个后缀L(例如：1L)
byte              1字节           1*8      -128 ~ 127

2.浮点型
类型               存储需求          bit数    取值范围          备注
float              4字节           4*8                       float类型的数值有一个后缀F(例如：3.14F)
double             8字节           8*8                       没有后缀F的浮点数值(如3.14)默认为double类型

3.char类型
类型              存储需求     bit数     取值范围      备注
char              2字节       2*8

4.boolean类型
类型              存储需求    bit数    取值范围      备注
boolean           1字节      1*8      false、true

[移位运算]
N/8 = N >> 3
N%8 = N & 7 = N & 0x07

N/64 = N >> 6
N%64 = N & 63 = N & 0x3F

十进制 <--> 十六进制：
16 <--> 10 : 15 <--> F  : 14 <--> E  : 13 <--> D  : 12 <--> C  : 11 <--> B  : 10 <--> A  : 10 <--> 10
32 <--> 20 : 31 <--> 1F : 30 <--> 1E : 29 <--> 1D : 28 <--> 1C : 27 <--> 1B : 26 <--> 1A : 25 <--> 19 : 24 <--> 18 : 23 <--> 17 : 22 <--> 16 : 21 <--> 15 : 20 <--> 14 : 19 <--> 13 : 18 <--> 12 : 17 <--> 11
48 <--> 30 : 47 <--> 2F : 46 <--> 2E : ..................................................: 41 <--> 29 : 40 <--> 28 : 39 <--> 27 : ..........
64 <--> 40 : 63 <--> 3F : 62 <--> 3E : ..................................................: 57 <--> 39 : 56 <--> 38 : 55 <--> 37 : ..........

[应用场景] https://blog.csdn.net/v_july_v/article/details/6685962
（1）给定40亿个不重复的 int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中。
解法：遍历40亿数字，映射到BitMap中，然后对于给出的数，直接判断指定的位上存在不存在即可。

（2）使用位图法判断整形数组是否存在重复
解法：遍历一遍，存在之后设置成1，每次放之前先判断是否存在，如果存在，就代表该元素重复。

（3）使用位图法进行元素不重复的整形数组排序
解法：遍历一遍，设置状态1，然后再次遍历，对状态等于1的进行输出，参考计数排序的原理。

（4）在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数
解法1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）。
解法2：采用两个BitMap，即第一个Bitmap存储的是整数是否出现，接着，在之后的遍历先判断第一个BitMap里面是否出现过，如果出现就设置第二个BitMap对应的位置也为1，最后遍历BitMap，仅仅在一个BitMap中出现过的元素，就是不重复的整数。
解法3：分治+Hash取模，拆分成多个小文件，然后一个个文件读取，直到内存装的下，然后采用Hash+Count的方式判断即可。

该类问题的变形问题，如已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==12MBytes，这样，就用了小小的12M左右的内存表示了所有的8位数的电话）


【最短路径的四大算法】
（Dijkstra & Floyd）https://www.jianshu.com/p/92e46d990d17

https://blog.csdn.net/qq_36386435/article/details/77403223
bellman-ford可以用于边权为负的图中，图里有负环也可以，如果有负环，算法会检测出负环。
时间复杂度O（VE）;
dijkstra只能用于边权都为正的图中。
时间复杂度O（n2）；
spfa是个bellman-ford的优化算法，本质是bellman-ford，所以适用性和bellman-ford一样。（用队列和邻接表优化）。
时间复杂度O（KE）;
floyd可以用于有负权的图中，即使有负环，算法也可以检测出来,可以求任意点的最短路径，有向图和无向图的最小环和最大环。
时间复杂度O（n3）；



